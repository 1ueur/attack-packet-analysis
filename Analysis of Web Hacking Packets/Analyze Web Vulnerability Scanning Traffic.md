## 💡 웹 취약점 스캐너
잘 알려진 취약점 스캐너는 Acunetix, Netspaker, OpenVAS, 레티나 CS 커뮤니티, Nikto 등이 있다. 
스캐너를 사용하여 허가, 인가되지 않은 곳을 무분별하게 악용하는 것은 금물이다.

### 🧸 Wireshark를 활용한 웹 취약점 스캔 패킷 분석
웹 스캔성 트래픽의 가장 큰 특징은 웹 서비스를 대상으로 다양한 공격을 매우 짧은 시간에 대량으로 요청한다는 것이다.
공격에 대한 영향력을 HTTP 응답을 통해 확인할 수 있다.

**웹 서버 응답 코드와 헤더** <br/>

![웹 서버 응답 코드와 헤더-1](https://user-images.githubusercontent.com/66156026/211150422-31f1f9ab-8e52-4774-8466-0785e096bf64.jpg)

TCP 스트림에서 주고 받은 데이터를 자세히 확인하고자 할 때는 패킷에 마우스 우클릭 - [Follow] - [TCP Stream]을 클릭한다.

![1](https://user-images.githubusercontent.com/66156026/211150867-232f359d-cac6-435a-b02a-00f62aaf5536.png)
![2](https://user-images.githubusercontent.com/66156026/211150870-84b7be96-74fb-487b-832c-ee788208997c.png)

HTTP의 요청과 응답(200 OK)만을 필터링하는 명령어는 다음과 같다.

```http.request.full_uri || http.response.cod==200```

필터가 적용되면 공격자가 요청한 HTTP URI와 웹 서버측에서 성공 응답(2xx)한 패킷만이 필터링된다.

![3](https://user-images.githubusercontent.com/66156026/211150872-1c09f2e7-a423-4965-b32d-5fde15d9ebd9.png)

일반적으로 **GET** 방식으로 **SQLi, Reflect XSS, LFI, RFI** 등의 취약점 공격 부류와 **POST** 방식으로 **Stored XSS, CSRF, Webshell Upload** 등의 공격 부류의 요청은 영향력이 없을 경우 403, 404와 같이 요청 오류(4xx) 코드로 응답한다.

<br/>

### 🧸 분석에 필요한 기초 개념: HTTP 트랜잭션(Transaction)
HTTP 프로토콜은 서버-클라이언트 모델이다. 클라이언트는 여러 세션을 가질 수 있으며, 각 세션은 여러 트랜잭션을 가질 수 있다.
클라이언트에서 서버로 요청을 전송하고 나서, 서버에서 응답하는 것을 트랜잭션 단위라고 할 수 있다. 즉 HTTP 트랜잭션은 서버-클라이언트 간의 양방향 통신의 단위를 나타낸다.
단위 구분은 요청할 때의 클라이언트 포트와 응답할 때의 서버 측 포트의 상호 작용하는 단위로 구분한다.

![세션](https://user-images.githubusercontent.com/66156026/211158084-975cff8e-4d27-4507-9b51-0aa3f5a00dd7.jpg)

HTTP 트랜잭션의 종료까지는 상호 간의 포트 번호가 변경되지 않는다. Wireshark의 패킷 우클릭 - [Follow TCP Stream] 메뉴는 출발지 포트와 도착지 포트의 상호 통신을 구분한다.

TCP Stream을 Wireshark Packet List 상단의 Columns(열)로 추가하여 정렬하면 HTTP 요청-응답을 한 눈에 볼 수 있다.

1. [Edit] - [Preferences] - [Columns] (맥 OS: 상단 Wireshark - [Preferences] - [Columns])
2. [Add]에서 [Filed type]은 "Custom", [Field name]에는 "tcp.stream" 입력

![11](https://user-images.githubusercontent.com/66156026/211159634-3e39f1ec-9cd1-4bd2-add1-0cbe4bff53dd.png)

추가하면 화면에 tcp.stream 열이 추가된 것을 확인할 수 있다. 다시 필터를 적용하고 컬럼을 클릭하면 HTTP 트랜잭션이 순서대로 정렬된다.

일반적인 HTTP 트랜잭션은 하나의 요청과 하나의 응답을 주고받기 때문에 요청에 대한 응답을 쉽게 찾아볼 수 있다. 하지만 하나의 출발지 포트에서 여러 요청이 발생한 경우 어느 HTTP 요청에 대한 응답인지 포트만 보고 구분할 수 없는 문제가 생긴다.

![22](https://user-images.githubusercontent.com/66156026/211159635-33fbf190-1ed7-4fa3-9428-eee3674d789f.png)

웹 스캔성 트래픽이 일반 트래픽과 달리 하나의 트랜잭션에 많은 요청이 발생하는 이유는 스캔하는 입장에서 많은 요청을 단시간에 발생시키고 그에 대한 빠른 응답을 받고자하기 때문이다.
이런 HTTP 요청 헤더에는 **Connection: Keep-Alive** 헤더가 붙을 수 있다.

![33](https://user-images.githubusercontent.com/66156026/211159637-bba0e595-60fa-48d7-93a6-5a30540c8013.png)

> **HTTP 1.1 Keep-Alive 기능** <br/>
> HTTP는 connection less 방식으로 연결을 매번 종료하고 새로 연결하는 구조이다.<br/>
> 이는 네트워크 비용 측면에서 큰 비용을 소비하는 구조이기 때문에 HTTP 1.1부터는 Keep-Alive 기능을 지원한다.<br/>
> Keep-Alive란 연결된 HTTP socket에 IN/OUT의 access가 마지막으로 종료된 시점부터 정의된 시간까지 access가 없더라도 대기하는 방식이다. 즉 정의된 시간 내에만 access가 이루어진다면 계속 연결된 상태를 유지할 수 있는 것이다.

columns에 tcp.ack와 tcp.nxtseq를 추가하면 요청 출발지 포트와 같은 포트일지라도 어느 HTTP 요청에 대한 응답인지 명확히 구분할 수 있다.
(tcp.stream 추가하는 법과 동일)

TCP 3-way-handshake 과정 이후 데이터 교환 과정에서 TCP Next sequence number의 값이 붙는다. 이는 클라이언트 GET 요청에 대한 다음 응답 TCP Ack 값을 의미한다.

![웹스캔](https://user-images.githubusercontent.com/66156026/211160229-488cc1c0-ea3b-45d1-843c-10f39e7e7059.png)

위와 같은 설정을 모두 마치고 나면 서버의 200OK가 수많은 요청 패킷들 중 어느 패킷에서 요청한 코드의 응답 코드인지 한 눈에 볼 수 있다. 아래 사진에서는 200 응답 패킷 바로 위에 있는 요청 패킷에 대한 응답이란 것을 빠르게 확인한다.

반드시 공격 요청에 대한 응답이 200 OK라 하더라도 반드시 취약하다고 단정지을 수는 없다. 그러나 이런 접근은 많은 공격에 대한 영향력을 파악하는 데 도움이 될 것이다.

<br/>

### 🧸 Network Miner를 활용한 웹 취약점 스캔 패킷 분석
Network Miner는 오픈 소스 네트워크 포렌식 분석 도구로 실시간 네트워크 트래픽을 캡쳐할 수 있고, 패킷 파일을 불러와 호스트의 OS 탐지, Host name, Sessions, 포트 등을 분석한다.

HTTP 응답 코드 200 OK 응답 페이지의 파일을 열어, 어떠한 정보가 외부에 노출되었는지 빠르게 확인할 수 있다.
SQL 인젝션 공격 구문을 HTTP URI 파라미터를 사용하였더라도 웹 방화벽이 설치된 경우는 응답 코드 200 OK와 함께 웹 방화벽에서 차단되었다는 내용의 페이지를 반환하거나 파라미터의 위치에 따라 정상 구문으로 인식해 요청에 대한 200 OK 응답을 반환할 수 있다.
(4xx, 5xx도 물론 가능.)

Network Miner는 응답 코드가 반환된 패킷 내의 파일 카빙을 할 수 있다. = 응답 페이지 파일들을 추출하여 직접 확인이 가능하다.

추출된 모든 파일을 확인할 필요는 없고, 파일 크기가 같은 페이지들은 몇 개의 파일을 열어 보고 더 확인할 필요가 없다. [File Size] 탭을 눌러 오름차순으로 정렬하여 본다.
**일관성없는** 크기의 html 페이지를 열어서 확인해보면, 취약점 페이지를 확인할 수 있다.

![network-miner](https://user-images.githubusercontent.com/66156026/211186706-0d9efc96-fa96-4cb6-bc77-6589a1d8f77c.png)

